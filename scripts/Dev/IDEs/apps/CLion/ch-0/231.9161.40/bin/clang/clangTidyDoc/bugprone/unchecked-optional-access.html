<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>clang-tidy - bugprone-unchecked-optional-access</title>
	/* CLION CLANG-TIDY DOCUMENTATION CSS PLACEHOLDER */
  </head>
  <body><div class="content"><section id="bugprone-unchecked-optional-access">
<h1>bugprone-unchecked-optional-access</h1>
<p><em>Note</em>: This check uses a flow-sensitive static analysis to produce its
results. Therefore, it may be more resource intensive (RAM, CPU) than the
average clang-tidy check.</p>
<p>This check identifies unsafe accesses to values contained in
<code class="docutils literal notranslate"><span class="pre">std::optional&lt;T&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">absl::optional&lt;T&gt;</span></code>, or <code class="docutils literal notranslate"><span class="pre">base::std::optional&lt;T&gt;</span></code>
objects. Below we will refer to all these types collectively as
<code class="docutils literal notranslate"><span class="pre">optional&lt;T&gt;</span></code>.</p>
<p>An access to the value of an <code class="docutils literal notranslate"><span class="pre">optional&lt;T&gt;</span></code> occurs when one of its
<code class="docutils literal notranslate"><span class="pre">value</span></code>, <code class="docutils literal notranslate"><span class="pre">operator*</span></code>, or <code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> member functions is invoked.
To align with common misconceptions, the check considers these member
functions as equivalent, even though there are subtle differences
related to exceptions versus undefined behavior. See
go/optional-style-recommendations for more information on that topic.</p>
<p>An access to the value of an <code class="docutils literal notranslate"><span class="pre">optional&lt;T&gt;</span></code> is considered safe if and only if
code in the local scope (for example, a function body) ensures that the
<code class="docutils literal notranslate"><span class="pre">optional&lt;T&gt;</span></code> has a value in all possible execution paths that can reach the
access. That should happen either through an explicit check, using the
<code class="docutils literal notranslate"><span class="pre">optional&lt;T&gt;::has_value</span></code> member function, or by constructing the
<code class="docutils literal notranslate"><span class="pre">optional&lt;T&gt;</span></code> in a way that shows that it unambiguously holds a value (e.g
using <code class="docutils literal notranslate"><span class="pre">std::make_optional</span></code> which always returns a populated
<code class="docutils literal notranslate"><span class="pre">std::optional&lt;T&gt;</span></code>).</p>
<p>Below we list some examples, starting with unsafe optional access patterns,
followed by safe access patterns.</p>
<section id="unsafe-access-patterns">
<h2>Unsafe access patterns</h2>
<section id="access-the-value-without-checking-if-it-exists">
<h3>Access the value without checking if it exists</h3>
<p>The check flags accesses to the value that are not locally guarded by
existence check:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">opt</span><span class="p">);</span><span class="w"> </span><span class="c1">// unsafe: it is unclear whether `opt` has a value.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="access-the-value-in-the-wrong-branch">
<h3>Access the value in the wrong branch</h3>
<p>The check is aware of the state of an optional object in different
branches of the code. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">use</span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">value</span><span class="p">());</span><span class="w"> </span><span class="c1">// unsafe: it is clear that `opt` does *not* have a value.</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="assume-a-function-result-to-be-stable">
<h3>Assume a function result to be stable</h3>
<p>The check is aware that function results might not be stable. That is,
consecutive calls to the same function might return different values.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">opt</span><span class="p">().</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">.</span><span class="n">opt</span><span class="p">());</span><span class="w"> </span><span class="c1">// unsafe: it is unclear whether `foo.opt()` has a value.</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="rely-on-invariants-of-uncommon-apis">
<h3>Rely on invariants of uncommon APIs</h3>
<p>The check is unaware of invariants of uncommon APIs. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">HasProperty</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">.</span><span class="n">GetProperty</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// unsafe: it is unclear whether `foo.GetProperty(&quot;bar&quot;)` has a value.</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="check-if-a-value-exists-then-pass-the-optional-to-another-function">
<h3>Check if a value exists, then pass the optional to another function</h3>
<p>The check relies on local reasoning. The check and value access must
both happen in the same function. An access is considered unsafe even if
the caller of the function performing the access ensures that the
optional has a value. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">opt</span><span class="p">);</span><span class="w"> </span><span class="c1">// unsafe: it is unclear whether `opt` has a value.</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">g</span><span class="p">(</span><span class="n">opt</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="safe-access-patterns">
<h2>Safe access patterns</h2>
<section id="check-if-a-value-exists-then-access-the-value">
<h3>Check if a value exists, then access the value</h3>
<p>The check recognizes all straightforward ways for checking if a value
exists and accessing the value contained in an optional object. For
example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">opt</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="check-if-a-value-exists-then-access-the-value-from-a-copy">
<h3>Check if a value exists, then access the value from a copy</h3>
<p>The criteria that the check uses is semantic, not syntactic. It
recognizes when a copy of the optional object being accessed is known to
have a value. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opt1</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opt1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">opt2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="ensure-that-a-value-exists-using-common-macros">
<h3>Ensure that a value exists using common macros</h3>
<p>The check is aware of common macros like <code class="docutils literal notranslate"><span class="pre">CHECK</span></code>, <code class="docutils literal notranslate"><span class="pre">DCHECK</span></code>, and
<code class="docutils literal notranslate"><span class="pre">ASSERT_THAT</span></code>. Those can be used to ensure that an optional object has
a value. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">DCHECK</span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">opt</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="ensure-that-a-value-exists-then-access-the-value-in-a-correlated-branch">
<h3>Ensure that a value exists, then access the value in a correlated branch</h3>
<p>The check is aware of correlated branches in the code and can figure out
when an optional object is ensured to have a value on all execution
paths that lead to an access. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">SomeOtherCondition</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... more code...</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">safe</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">opt</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="stabilize-function-results">
<h2>Stabilize function results</h2>
<p>Since function results are not assumed to be stable across calls, it is best to
store the result of the function call in a local variable and use that variable
to access the value. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">foo_opt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">opt</span><span class="p">();</span><span class="w"> </span><span class="n">foo_opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">foo_opt</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="do-not-rely-on-uncommon-api-invariants">
<h2>Do not rely on uncommon-API invariants</h2>
<p>When uncommon APIs guarantee that an optional has contents, do not rely on it –
instead, check explicitly that the optional object has a value. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">GetProperty</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">property</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>instead of the <cite>HasProperty</cite>, <cite>GetProperty</cite> pairing we saw above.</p>
</section>
<section id="do-not-rely-on-caller-performed-checks">
<h2>Do not rely on caller-performed checks</h2>
<p>If you know that all of a function’s callers have checked that an optional
argument has a value, either change the function to take the value directly or
check the optional again in the local scope of the callee. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">g</span><span class="p">(</span><span class="o">*</span><span class="n">opt</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">.</span><span class="n">opt</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">g</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="additional-notes">
<h2>Additional notes</h2>
<section id="aliases-created-via-using-declarations">
<h3>Aliases created via <code class="docutils literal notranslate"><span class="pre">using</span></code> declarations</h3>
<p>The check is aware of aliases of optional types that are created via
<code class="docutils literal notranslate"><span class="pre">using</span></code> declarations. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">OptionalInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">OptionalInt</span><span class="w"> </span><span class="n">opt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">value</span><span class="p">());</span><span class="w"> </span><span class="c1">// unsafe: it is unclear whether `opt` has a value.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="lambdas">
<h3>Lambdas</h3>
<p>The check does not currently report unsafe optional accesses in lambdas.
A future version will expand the scope to lambdas, following the rules
outlined above. It is best to follow the same principles when using
optionals in lambdas.</p>
</section>
</section>
</section>
</div></body>
</html>