<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>clang-tidy - readability-implicit-bool-conversion</title>
	/* CLION CLANG-TIDY DOCUMENTATION CSS PLACEHOLDER */
  </head>
  <body><div class="content"><section id="readability-implicit-bool-conversion">
<h1>readability-implicit-bool-conversion</h1>
<p>This check can be used to find implicit conversions between built-in types and
booleans. Depending on use case, it may simply help with readability of the code,
or in some cases, point to potential bugs which remain unnoticed due to implicit
conversions.</p>
<p>The following is a real-world example of bug which was hiding behind implicit
<code class="docutils literal notranslate"><span class="pre">bool</span></code> conversion:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">m_foo</span><span class="p">;</span><span class="w"></span>

<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">setFoo</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">m_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// warning: implicit conversion bool -&gt; int</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">getFoo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">m_foo</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">use</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">getFoo</span><span class="p">();</span><span class="w"> </span><span class="c1">// warning: implicit conversion int -&gt; bool</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This code is the result of unsuccessful refactoring, where type of <code class="docutils literal notranslate"><span class="pre">m_foo</span></code>
changed from <code class="docutils literal notranslate"><span class="pre">bool</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>. The programmer forgot to change all
occurrences of <code class="docutils literal notranslate"><span class="pre">bool</span></code>, and the remaining code is no longer correct, yet it
still compiles without any visible warnings.</p>
<p>In addition to issuing warnings, fix-it hints are provided to help solve the
reported issues. This can be used for improving readability of code, for
example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">conversionsToBool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">floating</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">floating</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ^ propose replacement: bool boolean = floating != 0.0f;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">integer</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ^ propose replacement: if (integer != 0) {}</span>

<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pointer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pointer</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ^ propose replacement: if (pointer == nullptr) {}</span>

<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ^ propose replacement: while (true) {}</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">functionTakingInt</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">param</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">conversionsFromBool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">boolean</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">functionTakingInt</span><span class="p">(</span><span class="n">boolean</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ^ propose replacement: functionTakingInt(static_cast&lt;int&gt;(boolean));</span>

<span class="w">  </span><span class="n">functionTakingInt</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ^ propose replacement: functionTakingInt(1);</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In general, the following conversion types are checked:</p>
<ul class="simple">
<li><p>integer expression/literal to boolean (conversion from a single bit bitfield
to boolean is explicitly allowed, since thereâ€™s no ambiguity / information
loss in this case),</p></li>
<li><p>floating expression/literal to boolean,</p></li>
<li><p>pointer/pointer to member/<code class="docutils literal notranslate"><span class="pre">nullptr</span></code>/<code class="docutils literal notranslate"><span class="pre">NULL</span></code> to boolean,</p></li>
<li><p>boolean expression/literal to integer (conversion from boolean to a single
bit bitfield is explicitly allowed),</p></li>
<li><p>boolean expression/literal to floating.</p></li>
</ul>
<p>The rules for generating fix-it hints are:</p>
<ul class="simple">
<li><p>in case of conversions from other built-in type to bool, an explicit
comparison is proposed to make it clear what exactly is being compared:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">boolean</span> <span class="pre">=</span> <span class="pre">floating;</span></code> is changed to
<code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">boolean</span> <span class="pre">=</span> <span class="pre">floating</span> <span class="pre">==</span> <span class="pre">0.0f;</span></code>,</p></li>
<li><p>for other types, appropriate literals are used (<code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">0u</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0f</span></code>,
<code class="docutils literal notranslate"><span class="pre">0.0</span></code>, <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>),</p></li>
</ul>
</li>
<li><p>in case of negated expressions conversion to bool, the proposed replacement
with comparison is simplified:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(!pointer)</span></code> is changed to <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(pointer</span> <span class="pre">==</span> <span class="pre">nullptr)</span></code>,</p></li>
</ul>
</li>
<li><p>in case of conversions from bool to other built-in types, an explicit
<code class="docutils literal notranslate"><span class="pre">static_cast</span></code> is proposed to make it clear that a conversion is taking
place:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">integer</span> <span class="pre">=</span> <span class="pre">boolean;</span></code> is changed to
<code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">integer</span> <span class="pre">=</span> <span class="pre">static_cast&lt;int&gt;(boolean);</span></code>,</p></li>
</ul>
</li>
<li><p>if the conversion is performed on type literals, an equivalent literal is
proposed, according to what type is actually expected, for example:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">functionTakingBool(0);</span></code> is changed to <code class="docutils literal notranslate"><span class="pre">functionTakingBool(false);</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">functionTakingInt(true);</span></code> is changed to <code class="docutils literal notranslate"><span class="pre">functionTakingInt(1);</span></code>,</p></li>
<li><p>for other types, appropriate literals are used (<code class="docutils literal notranslate"><span class="pre">false</span></code>, <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>,
<code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">0u</span></code>, <code class="docutils literal notranslate"><span class="pre">1u</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0f</span></code>, <code class="docutils literal notranslate"><span class="pre">1.0f</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, <code class="docutils literal notranslate"><span class="pre">1.0f</span></code>).</p></li>
</ul>
</li>
</ul>
<p>Some additional accommodations are made for pre-C++11 dialects:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">false</span></code> literal conversion to pointer is detected,</p></li>
<li><p>instead of <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> literal, <code class="docutils literal notranslate"><span class="pre">0</span></code> is proposed as replacement.</p></li>
</ul>
<p>Occurrences of implicit conversions inside macros and template instantiations
are deliberately ignored, as it is not clear how to deal with such cases.</p>
<section id="options">
<h2>Options</h2>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-arg-AllowIntegerConditions">
<span id="cmdoption-arg-allowintegerconditions"></span><span class="sig-name descname"><span class="pre">AllowIntegerConditions</span></span><span class="sig-prename descclassname"></span></dt>
<dd><p>When <cite>true</cite>, the check will allow conditional integer conversions. Default
is <cite>false</cite>.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-arg-AllowPointerConditions">
<span id="cmdoption-arg-allowpointerconditions"></span><span class="sig-name descname"><span class="pre">AllowPointerConditions</span></span><span class="sig-prename descclassname"></span></dt>
<dd><p>When <cite>true</cite>, the check will allow conditional pointer conversions. Default
is <cite>false</cite>.</p>
</dd></dl>

</section>
</section>
</div></body>
</html>